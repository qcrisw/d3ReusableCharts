<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>
		<title>D3 ActigraVis</title>
    <link href="_/agv-d3-style.css" rel="stylesheet"></link>
  </head>
  <body>
    <div id="chart-id" class="scatter-plot"></div>
    <ul class="legend"></ul>
    <script>
      // function makeScatterPlot() {}
      var parentNode = d3.select('#chart-id').node(),
          parent = '#chart-id';

      const margin = { left: 70, right: 10, top: 10, bottom: 120 };

      var containerwidth = parentNode.getBoundingClientRect().width,
      containerheight = parentNode.getBoundingClientRect().height,
      width = containerwidth - margin.left - margin.right,
      height = containerheight - margin.top - margin.bottom;
      // const innerWidth = width - margin.left - margin.right;
      // const innerHeight = height - margin.top - margin.bottom;


    var svg = d3.select(parent)
    .append('svg')
    .attr('width', containerwidth)
    .attr('height', containerheight);
    var g = svg.append('g')
    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
    var tooltip = d3.select(parent)
    .append('div')                                  .attr('class', 'd3-tooltip hidden');
     // $(window).on('resize', function() {
     // containerwidth = parentNode.getBoundingClientRect().width,
     // containerheight = parentNode.getBoundingClientRect().height,
     // width = containerwidth - margin.left - margin.right,
     // height = containerheight - margin.top - margin.bottom; })

    // few specifics
    var format = d3.format(".2s");
    const xValue = d => d.x;
    const xLabel = 'xLabel';
    const yValue = d => d.y;
    const yLabel = 'yLabel';

	  //grid lines
		const xScale = d3.scaleLinear();
		const yScale = d3.scaleLinear();

    const xAxisG = g.append('g')
        .attr('transform', `translate(0, ${height})`);
    xAxisG.append('text')
        .attr('class', 'axis-label')
        .attr('x', width / 2)
        .attr('y', 45)
        .text(xLabel);
    const yAxisG = g.append('g');
    yAxisG.append('text')
        .attr('class', 'axis-label')
        .attr('x', -height / 2)
        .attr('y', -55)
        .attr('transform', `rotate(-90)`)
        .style('text-anchor', 'middle')
        .text(yLabel);

				// axis
    const xAxis = d3.axisBottom()
      .scale(xScale)
      .ticks(10)
      .tickPadding(15)
      .tickFormat(function(d) {return format(d)})
      .tickSize(-height);
    const yAxis = d3.axisLeft()
      .scale(yScale)
      .ticks(10)
      .tickPadding(15)
      .tickFormat(function(d) {return format(d)})
      .tickSize(-width);

  d3.json('_/agv-data.json', function(error, data) {
    if (error) throw error;
    //AGV data from Backend is nested. So, flattening or ungrouping nested data
    var dataUnGroup = []
    data.forEach(function(d){
      // for Individuals
      if(d.isGroup == false){
        dataUnGroup.push({
         "isGroup": d.isGroup,
         "key": d.key,
         "color": d.color,
         "values": d.values,
         "x": d.x,
         "y": d.y,
      	 "xMin": d.xMin,
      	 "xMax": d.xMax,
      	 "xStdDev": d.xStdDev,
      	 "yMin": d.yMin,
      	 "yMax": d.yMax,
      	 "yStdDev": d.yStdDev,
      	 "label": d.label,
          })
        }
      // for Groups
      else if(d.isGroup == true){
        d.values.forEach(function(e) {
        dataUnGroup.push({
        "isGroup": d.isGroup,
        "key": d.key,
        "color": d.color,
        "x": e.x,
        "y": e.y,
        "xMin": e.xMin,
      	"xMax": e.xMax,
      	"xStdDev": e.xStdDev,
      	"yMin": e.yMin,
      	"yMax": e.yMax,
      	"yStdDev": e.yStdDev,
      	"label": e.label,
      	"values": e.values // copies all e.label's x and y raw values
          })
        })
      }
    })
    // finding max value of xMax and yMax in data
    var i,j,xMaxX,yMaxY;
    var allX = [];
    var allY = [];
    for(i in data) {
      if(data[i].isGroup == true){
        for(j in data[i].values) {
      		allX.push(data[i].values[j].xMax)
      		allY.push(data[i].values[j].yMax)
      		var x = data[i].values[j].values;
        }
      }
      xMaxX = allX.reduce(function(a, b) { return Math.max(a, b); });
      yMaxY = allY.reduce(function(a, b) { return Math.max(a, b); });
    }

    xScale
    .domain([0, xMaxX])
    .range([0, width])
    .nice();

    yScale
    .domain([0, yMaxY])
    .range([height, 0])
    .nice();

    // create second yScale for invert height range starting 0
    const yScale2 = d3.scaleLinear()
      .domain([0, yMaxY])
    	.range([0, height])
    	.nice();

    g.selectAll('circle').data(dataUnGroup)
    .enter().append('circle')
      .attr('cx', d => xScale(xValue(d)))
      .attr('cy', d => yScale(yValue(d)))
      .attr('fill', d => d.color)
      .attr('fill-opacity', 1.0)
      .attr('r', 8)
    	.on("mouseover", function(d) {
    				d3ScatterplotMouseOver(d);
    		})
    	.on("mouseout", function(d) {
            tooltip.classed('hidden', true);
    				d3.selectAll('rect').remove();
    		})
    	.on("click", function(d) {
    				d3ScatterplotClick(d, data);
    	})
    	.on("dblclick", function(d) {
    				console.log("byeeee");
    	});

    xAxisG.call(xAxis);
    yAxisG.call(yAxis);

    function d3ScatterplotMouseOver(d){
      //tooltip
      var mouse = d3.mouse(svg.node()).map(function(d) {
          return parseInt(d);
      });
      var left = Math.min(containerwidth, mouse[0]+margin.left+margin.right),
      top = Math.min(containerheight, mouse[1]+margin.top+margin.right);
      var tooltipHtml = "<p class='text-capitalize'>Subject: <b>"+d.label+"</b></p><p>"+xLabel+": <b>"+d.x+"</b></p><p>"+yLabel+": <b>"+ d.y+"</b></p>";
      tooltip.html(tooltipHtml)
      .classed('hidden', false)
      .style('left', left + 'px')
      .style('top', top + 'px');

      if(d.values != null && d.values.length >> 1){
        var sWidth = (xScale(2 * d.xStdDev));
        var sHeight = (yScale2(2 * (d.yStdDev)  ));
        var sposX = xScale(d.x - d.xStdDev);
        var sposY = yScale(d.y + d.yStdDev);
        g.append("rect")
        .attr("x", sposX)
        .attr("y", sposY)
        .attr("width", sWidth)
        .attr("height", sHeight)
        .attr("stroke", "#444")
        .attr("fill", "none");

        var mXp =  xScale(d.xMin);
        var mYp =  yScale(d.yMax);
        var mWidth = xScale(d.xMax - d.xMin)
        var mHeight = yScale2(d.yMax - d.yMin)
        g.append("svg:rect")
        .attr("x",mXp)
        .attr("y",mYp)
        .attr("width", mWidth)
        .attr("height", mHeight)
        .attr("stroke", "#ff0000")
        .attr("fill", "none");
      }
    }

    function d3ScatterplotClick(d, json){
    var newValues;
    console.log("d", d);
    if(d.values.length >>  1){
    console.log("val lenght", d.values.length);
    newValues = d.values;
     for(i in newValues) {
       // add new key-value pairs to newValues
       newValues[i]['newlyAdd'] = 1;
       newValues[i]['label'] = d.values[i].label;
     }
     for(var i in newValues){
       json.push(newValues[i]);
     }
              g.append('circle').data(newValues)
               .attr('cx', e => xScale(xValue(e)))
               .attr('cy', e => yScale(yValue(e)))
               .attr('fill', '#f00')
               .attr('r', 8)
               .attr("class", "WWAAA")
               .attr("id", e=> (newValues.label));
    }

    if(d.values == null && d.newlyAdd == 1){
    console.log("remove d",d);
    json.splice(2, 1);
    }
    }


  });

    </script>

  </body>
</html>
